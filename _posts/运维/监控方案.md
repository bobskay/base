---
title: 监控系统设计
date: 2018-08-14 17:42:01
categories: [design]
tags: [监控]
typora-copy-images-to: ../images
typora-root-url:  E:/blog
---

监控的重要性不言而喻，系统许多优化都必须建立在实际数据的基础上。

然而监控范围，监控频率以及监控数据保存时间一直是令人头疼的问题。

理想情况当然是越精确越好，但由于收性能和存储所限，往往都要对其中一部分做一些取舍

<!--more-->

# 数据存储

假设监控项有1W个，监控的数据类型为int32，记录为每分钟1条，那么理论上储存90天的数据最少需要

```java
10000*4字节*60分钟*24小时*90天/1024B/1024K/1024M=4.82G
```

实际上由于存储方式的不同，大部分情况下1条数据的占用空间远不止4个字节。

## 优化方案

### 定期汇总

所以为了解决存储的问题，通常的做法是近期保存精确数据，长期保存趋势数据，超过1定时期的数据通过平均或求和的方式做一次汇总，将1分钟粗化到5分钟，1小时，1天，1周，甚至是1个月。

### 索引方式

考虑到监控数据的特殊性，大部分监控项的取值范围其实变化不大，而且通常如果出现了未预计的统计范围，说明系统需要人工干预了。所以我将一份监控数据分2个地方存放，1个保存普通范围内的数据，1个保存超出范围的数据。

针对普通范围内的数据，正常情况下99%的数据都应该是在这个范围内的，而且由于是正常数据，所以粒度还能粗化，例如

- 正常情况下cup使用率是10%还是11%其实没有却别，我们都可以记为10
- 当一个接口1分钟内的平均访问量是10，如果统计粒度是秒，全部变动值都是8-12，那么将每秒都记录为10其实是没任何问题的，因为1秒内的订单算到上一秒和算到下一秒都是合理的。

这样做以后，保存数据时，只需要在头部保存所有可选值的范围，具体数据只存在这个范围内的索引位置。如下面这种结构

| heaer | 5      | 10     | 15   | 20   |
| ----- | ------ | ------ | ---- | ---- |
|       | 保存值 | 实际值 |      |      |
| data1 | 0      | 5      |      |      |
| data2 | 1      | 10     |      |      |
| data3 | 1      | 10     |      |      |
| data4 | 2      | 15     |      |      |
| data5 | 0      | 5      |      |      |
| data6 | 1      | 10     |      |      |
| data7 | 3      | 20     |      |      |
| data8 | 0      | 5      |      |      |

因为数据项只有4个，实际存储时可以只用2个bit，这样保存上面8条数据只需要用到2个字节，空间一下减少到了原来的1/4

### 压缩

许多监控数据的变化都是周期性的，例如JVM的内存使用情况，总是缓慢增长，然后在某次GC后回到某一个值

![1534261990864](/blog/images/1534261990864.png)

针对这种数据，一些通用的压缩算法就能很好的处理，拿一段测试数据，分别用nappy和zip压缩

```java
public static void main(String[] args) throws Exception {
    ByteBuf buff = Unpooled.buffer();
    int data=0;
    //12(5秒1次)*60分钟*24小时*90天
    for (int i = 0; i < 1555200; i++) {
        data++;
        if(data%1000==0) {
            data=0;
        }
        buff.writeInt(data);
    }

    createFile(buff,Compress.NONE);
    createFile(buff,Compress.ZIP);
    createFile(buff,Compress.SNAPPY);
}
```

结果为

![1534263308976](/blog/images/1534263308976.png)

| 原始大小 | snappy | zip  |
| -------- | ------ | ---- |
| 6076K    | 1002K  | 39K  |

极端情况下，5秒钟统计一次，90天的数据只要占用39K的磁盘空间

# 数据采集

数据采用，可以采用服务端主动和客户端主动两种方式。但由服务端主动发起的方式存在一些弊端，因为服务端无法获知数据变化情况，所以大部分情况下服务端拉取的可能都是无变化或者变化不大的数据。而且大部分情况下服务端只能按监控项取值，这就造成了发起的链接好多，但大部分链接获取的数据量很少。

这里采用客户采集，然后根据根据时间或者某些条件，将数据发送给服务端的方式。而且由于上面说到的数据存储方案，客户端可以将一些取值范围相近的数据做一次处理然后统计发送，这样不仅减少请求次数，而且可以减少数据的发送量

| 开始时间 | 1514736000000 | 周期(秒) | 5     |      |
| -------- | ---- | -------- | ----- | ---- |
| heaer    | 5           | 10       | 15    | 20   |
| 位置     | item1       | item2    | item3 | …    |
| 1        | 0           | 0        | 0     |      |
| 2        | 1           | 1        | 2     |      |
| 3        | 1           | 2        | 3     |      |
| 4        | 2           | 2        | 3     |      |
| 5        | 0           | 1        | 2     |      |
| 6        | 1           | 3        | 3     |      |
| 7        | 3           | 1        | 2     |      |
| 8        | 0           | 2        | 3     |      |
| …        |             |          |       |      |

# 可视化

通过Echarts实现

![1534301572364](/blog/images/1534301572364.png)

