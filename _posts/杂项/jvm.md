---
title: jvm
date: 2018-07-30 18:01:30
categories: [code,java]
tags: [jvm]
typora-copy-images-to: ../images
typora-root-url:  E:/blog
---

jvm内存模型

<!--more-->

# Java内存区域

只是概念

![](/blog/images/20170608140321198.png)

## 堆区: 

1. 存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) 
2. jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 

## 栈区: 

1. 每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中 

2. 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。 

3. 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 

## 方法区: 

1. 又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 
2. 方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 

# Java内存模型

- 主内存

  主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该**实例对象是成员变量还是方法中的本地变量(也称局部变量)**，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。

- 工作内存

  主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。

倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存 

![](/blog/images/20170609093435508.png)

# 硬件内存架构

![](/blog/images/20170611211802727.png)

# Java线程与硬件处理器

Java线程的实现是基于一对一的线程模型，所谓的一对一模型，实际上就是通过语言级别层面程序去间接调用系统内核的线程模型，即我们在使用Java线程时，Java虚拟机内部是转而调用当前操作系统的内核线程来完成当前任务 

![](/blog/images/20170608094427710.png)

# 垃圾收集

VisualVM截图

![1533024036245](/blog/images/1533024036245.png)

## 判断对象是否存活

### 可达性分析算法

对象到GC Roots没有引用链，则回收。

GC Roots包括：

- （1）Java虚拟机栈中引用的对象。
- （2）方法区中类静态属性引用的对象。
- （3）方法去中常量引用的对象。
- （4）本地方法栈中Native方法（JNI）引用的对象。

### 关于引用

- （1）强引用：Object obj = new Object()，不会被jvm回收
- （2）软引用：在内存溢出异常发生之前才被强制回收。

```java
 SoftReference<String> sr = new SoftReference<String>(new String("hello"));
```

- （3）弱引用：延迟到下次垃圾回收之前再被回收。
- （4）虚引用：仅为了在被回收时收到一个系统通知。

## 垃圾收集算法

### 标记-清除算法（Mark-Sweep）

- 效率问题：标记和清除两个过程的效率都不高。
- 空间问题：清除后剩余空间零散不连续，无法为大的对象分配内存。

### 复制算法

将内存分为两个半区，将区A中的存活对象全部复制到B区的连续空间，然后清理A中所有空间。

缺点：内存实际空间减半。在对象存活率较高时需要进行较多的复制操作。

实际应用：将堆内存分为新生代和老年代。由于新生代中的对象98%都是可回收的，故将新生代又划分为Eden空间和两块较小的Survivor空间，默认Eden:Survivor（单个）=8:1

这样每次垃圾收集时，将Eden和S1中的存活对象复制到S2，然后清空Eden和S1区。

为了防止S2中空间不足以存储Eden和S1的所有剩余存活对象，提供老年代作为保障（Handle Promotion：分配担保）。

### 标记-整理算法

将标记后的存活对象进行移动，清除剩余对象。

应用：老年代

#### 分代收集

- 新生代：存活率低，使用复制算法
- 老年代：存活率高，使用“标记-整理”或“标记-清除”算法

## 垃圾收集器

### Parallel Scavenge收集器

新生代、复制算法、多线程。

注重吞吐量，适合后台进程。

-XX:MacGCPauseMillis：最大垃圾收集停顿时间

-XX:GCTimeRatio：吞吐量大小

GCTimeRatio=99，意味着允许最大垃圾收集时间占比为1/(1+99)=1%，GCTimeRatio=用户代码运行时间/GC时间。

-XX:+UseAdaptiveSizePolicy：动态自适应调整JVM参数（-Xmn、SurvivorRatio等）	

### Parallel Old收集器

Parallel Scavenge的老年代版本

### G1收集器

最前沿成果。削弱新生代与老年代概念，将整个堆划分为独立的不同Region。根据各Region的回收价值，确定优先列表。

从整体来看：“标记-整理” 算法

从局部（两个Region之间）来看：“复制”算法

## jvm默认垃圾收集器

jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）

jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）

jdk1.9 默认垃圾收集器G1

-XX:+PrintCommandLineFlagsjvm参数可查看默认设置收集器类型

-XX:+PrintGCDetails亦可通过打印的GC日志的新生代、老年代名称判断

## 内存分配与回收策略

#### 优先在Eden区分配（如果启动本地线程分配缓冲TLAB-Thread Local Allocation Buffer，则优先在TLAB）

如果Eden区满，则触发一次Minor GC(也称Young GC)

-XX:+PrintGCDetails

- 在JVM发生垃圾收集时打印内存回收日志
- 在进程退出时输出当前各区域的内存分配情况

在JDK8中，PermGen（永久代）被Metaspace（元空间）取代了。

#### 大对象直接进入老年代

-XX:PretenureSizeThreshold：直接进入老年代的对象大小

#### 长期存活的对象将进入老年代

-XX:MaxTenuringThreshold：设置对象在新生代中能存活的最大年龄，默认15

-XX:+PrintTenuringDistribution：打印老年代内的各年龄对象内存分配情况

#### 动态对象年龄判定

若Survivor中相同年龄的所有对象大小总和超过Survivor的一半，则年龄大于或等于该年龄的对象就可以直接进入老年代。

#### 空间分配担保

- （1）YGC发生前先检查“老年代最大可用的连续空间”是否大于新生代所有对象总空间。如果是，则触发YGC,无风险；如果否，进入（2）
- （2）再次判断“老年代最大可用的连续空间”是否大于历次平均晋升到老年代的对象大小总和。如果否，则直接执行FullGC；如果是，进入（3）
- （3）执行YGC，有风险。
- （4）如果3中的YGC失败，则再执行FullGC。